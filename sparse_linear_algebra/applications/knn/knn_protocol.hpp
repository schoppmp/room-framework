#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <random>
#include "mpc_utils/benchmarker.hpp"
#include "mpc_utils/comm_channel.hpp"
#include "sparse_linear_algebra/oblivious_map/oblivious_map.hpp"

namespace sparse_linear_algebra {
namespace applications {
namespace knn {

enum MulType { dense, sparse };
enum PirType { basic, poly, scs };

// Encapsulation class for running KNN.
template <typename T>
class KNNProtocol {
 public:
  using element_type = T;

  // disable move and copy
  KNNProtocol(const KNNProtocol&) = delete;
  KNNProtocol& operator=(const KNNProtocol&) = delete;
  KNNProtocol(KNNProtocol&&) = delete;
  KNNProtocol& operator=(KNNProtocol&&) = delete;

  KNNProtocol(comm_channel* channel, int party_id, int16_t statistical_security,
              int precision, MulType mt, PirType pt, int chunk_size, int k,
              int64_t num_documents_server, int64_t num_words,
              int64_t num_documents_client, int num_nonzeros_server,
              int num_nonzeros_client,
              Eigen::SparseMatrix<T, Eigen::RowMajor> server_matrix,
              Eigen::SparseMatrix<T, Eigen::ColMajor> client_matrix);

  // Returns the result of a complete protocol run, i.e a vector of the
  // top `k` matches.
  std::vector<int> run(mpc_utils::Benchmarker* benchmarker = nullptr);

 private:
  void computeSimilarities(mpc_utils::Benchmarker* benchmarker);

  std::vector<int> topK(mpc_utils::Benchmarker* benchmarker);

  comm_channel* channel_;
  const int party_id_;
  std::map<PirType, std::shared_ptr<oblivious_map<int, int>>> pir_protocols_;
  const MulType mul_type_;
  const PirType pir_type_;
  const int precision_;
  const int chunk_size_;
  const int k_;
  const int64_t num_documents_server_;
  const int64_t num_words_;
  const int64_t num_documents_client_;
  // TODO: num_nonzeros_server_ can be computed in the constructor and is
  // therefore non-const. We should probably use a factory pattern here and make
  // it const.
  int num_nonzeros_server_;
  const int num_nonzeros_client_;
  // Input matrices randomly generated by `generateRandomMatrices`.
  Eigen::SparseMatrix<T, Eigen::RowMajor> server_matrix_;
  Eigen::SparseMatrix<T, Eigen::ColMajor> client_matrix_;
  // Shared result calculated by `computeSimilarities`.
  Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result_matrix_;
};

}  // namespace knn
}  // namespace applications
}  // namespace sparse_linear_algebra