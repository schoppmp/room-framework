#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <random>
#include "mpc_utils/comm_channel.hpp"
#include "mpc_utils/benchmarker.hpp"
#include "sparse_linear_algebra/oblivious_map/oblivious_map.hpp"

namespace sparse_linear_algebra {
namespace applications {
namespace knn {

enum MulType { dense, sparse };
enum PirType { basic, poly, scs };

// Encapsulation class for running KNN.
template <typename T>
class KNNProtocol {
 public:
  using element_type = T;

  // disable move and copy
  KNNProtocol(const KNNProtocol&) = delete;
  KNNProtocol& operator=(const KNNProtocol&) = delete;
  KNNProtocol(KNNProtocol&&) = delete;
  KNNProtocol& operator=(KNNProtocol&&) = delete;

  KNNProtocol(comm_channel* channel, int party_id, int16_t statistical_security,
              int precision, MulType mt, PirType pt, size_t chunk_size,
              size_t k, size_t num_documents_server, size_t num_words,
              size_t num_documents_client, size_t num_nonzeros_server,
              size_t num_nonzeros_client,
              Eigen::SparseMatrix<T, Eigen::RowMajor> server_matrix,
              Eigen::SparseMatrix<T, Eigen::ColMajor> client_matrix);

  // Returns the result of a complete protocol run, i.e a vector of the
  // top `k` matches.
  std::vector<int> run(mpc_utils::Benchmarker* benchmarker = nullptr);

 private:
  void computeSimilarities(mpc_utils::Benchmarker* benchmarker);

  std::vector<int> topK(mpc_utils::Benchmarker* benchmarker);

  comm_channel* channel;
  const int party_id;
  std::map<PirType, std::shared_ptr<oblivious_map<int, int>>> pir_protocols;
  const MulType mt;
  const PirType pt;
  const int precision;
  const size_t chunk_size;
  const size_t k;
  const size_t num_documents_server;
  const size_t num_words;
  const size_t num_documents_client;
  const size_t num_nonzeros_server;
  const size_t num_nonzeros_client;
  // input matrices randomly generated by `generateRandomMatrices`
  Eigen::SparseMatrix<T, Eigen::RowMajor> server_matrix;
  Eigen::SparseMatrix<T, Eigen::ColMajor> client_matrix;
  // shared result calculated by `computeSimilarities`
  Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result_matrix;
};

}  // namespace knn
}  // namespace applications
}  // namespace sparse_linear_algebra