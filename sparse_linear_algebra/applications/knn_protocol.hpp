#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <random>
#include "mpc_utils/comm_channel.hpp"
#include "sparse_linear_algebra/oblivious_map/oblivious_map.hpp"

namespace sparse_linear_algebra::applications::knn {
  using T = uint64_t;

  enum MulType { dense, sparse };
  enum PirType { basic, poly, scs };

  // TODO: printing types will print integers, tix this

  // Encapsulation class for running KNN with random test data.
  class KNNProtocol {
  public:
    // disable move and copy
    KNNProtocol(const KNNProtocol&) = delete;
    KNNProtocol& operator=(const KNNProtocol&) = delete;
    KNNProtocol(KNNProtocol &&) = delete;
    KNNProtocol& operator=(KNNProtocol &&) = delete;

    KNNProtocol(comm_channel* channel, int party_id, int16_t statistical_security,
        int precision, MulType mt, PirType pt, size_t chunk_size,
        size_t k, size_t num_documents_server, size_t num_words, size_t num_documents_client, size_t num_nonzeros_server,
        size_t num_nonzeros_client,
        Eigen::SparseMatrix<T, Eigen::RowMajor> server_matrix,
        Eigen::SparseMatrix<T, Eigen::ColMajor> client_matrix);

    // Returns the result of a complete protocol run, i.e a vector of the
    // top `k` matches.
    std::vector<int> run();

  private:
    void computeSimilarities();

    std::vector<int> topK();

    comm_channel* channel;
    const int party_id;
    std::map<PirType, std::shared_ptr<oblivious_map<int, int>>> pir_protocols;
    const MulType mt;
    const PirType pt;
    const int precision;
    const size_t chunk_size;
    const size_t k;
    const size_t num_documents_server;
    const size_t num_words;
    const size_t num_documents_client;
    const size_t num_nonzeros_server;
    const size_t num_nonzeros_client;
    // input matrices randomly generated by `generateRandomMatrices`
    Eigen::SparseMatrix<T, Eigen::RowMajor> server_matrix;
    Eigen::SparseMatrix<T, Eigen::ColMajor> client_matrix;
    // shared result calculated by `computeSimilarities`
    Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> result_matrix;
  };

}