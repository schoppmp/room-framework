#include "oram_fssl/fss_cprg.oh"
#include "oram_fssl/floram.h"
#include "benchmark_fss.h"
#include <time.h>

double wallclock_millis() {
  struct timespec t;
  clock_gettime(CLOCK_REALTIME,&t);
  return 1e3*t.tv_sec+1e-6*t.tv_nsec;
}

void benchmark_fss(void *vargs) {
  struct BenchmarkFSSArgs *args = vargs;

  uint8_t *y = calloc(args->len, BLOCKSIZE);
  bool *bits = calloc(args->len,  sizeof(bool));
  obliv uint8_t *active_block_delta = calloc(1, BLOCKSIZE * sizeof(obliv uint8_t));

  // create fss object
  fss_cprg *fss = fss_cprg_new(args->len, 1);

  // run multiple iterations and average running time
  double start = wallclock_millis();
  for(size_t i = 0; i < args->num_iterations; i++) {
    size_t index = (args->len / 3) + i; // arbitrary
    // get blockvector
    fss_cprg_getblockvector(active_block_delta, y, bits, fss, index);
  }
  double end = wallclock_millis();
  args->result_time = (end - start) / args->num_iterations;

  // // check if result looks correct
  // bool at_index, not_at_index;
  // revealOblivBool(&at_index, feedOblivBool(bits[index], 1) ^ feedOblivBool(bits[index], 2), 0);
  // revealOblivBool(&not_at_index, feedOblivBool(bits[index+1], 1) ^ feedOblivBool(bits[index+1], 2), 0);
  // printf("at_index = %d, not_at_index = %d\n", at_index, not_at_index);

  free(y);
  free(bits);
  free(active_block_delta);
  fss_cprg_free(fss);
}
