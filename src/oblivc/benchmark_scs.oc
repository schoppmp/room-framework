#include "obliv.oh"
#include "osort.oh"
#include "benchmark_scs.h"
#include "benchmark_common.h"

struct L {
  obliv uint32_t v;
  obliv bool valid;
};

// compares elements of L by their `v` member
obliv char cmp_L_v(OcCopy *_cpy, void *el1, void *el2) {
  struct L *l1 = el1, *l2 = el2;
  obliv char ret = -1;
  obliv if(l1->v > l2->v) {
    ret = 1;
  }
  return ret;
}

obliv char cmp_uint32(OcCopy *_cpy, void *el1, void *el2) {
  obliv uint32_t *l1 = el1, *l2 = el2;
  obliv char ret = -1;
  obliv if (*l1 > *l2) {
    ret = 1;
  }
  return ret;
}

void benchmark_scs(void *vargs) {
  struct BenchmarkSCSArgs *args = vargs;
  double start = wallclock_millis();

  // set sizes assumed public
  size_t len1 = ocBroadcastLLong(args->len, 1);
  size_t len2 = ocBroadcastLLong(args->len, 2);

  struct L *L = calloc(len1 + len2, sizeof(struct L));
  obliv uint32_t *M = calloc(len1 + len2, sizeof(obliv uint32_t));
  OcCopy cpy_L = ocCopyBoolN(sizeof(struct L) / sizeof(obliv bool));

  // feed inputs by party 1
  for(size_t i = 0; i < len1; i++) {
    bool valid = (i < args->len);
    L[i].v = feedOblivInt(valid ? args->values[i] : UINT32_MAX, 1);
  }
  // feed inputs by party 2
  for(size_t i = 0; i < len2; i++) {
    bool valid = (i < args->len);
    L[len1+i].v = feedOblivInt(valid ? args->values[i] : UINT32_MAX, 2);
  }

  // merge sorted arrays
  omerge_batcher(&cpy_L, L, len1, len1+len2, cmp_L_v);

  // for(size_t i = 0; i < len1 + len2; i++) {
  //   uint32_t el;
  //   revealOblivInt(&el, L[i].v, 1);
  //   if(ocCurrentParty() == 1) {
  //     printf("%d ", el);
  //   }
  // }
  // if(ocCurrentParty() == 1) {
  //   printf("\n");
  // }

  // count intersection size
  obliv size_t count_intersection = 0;
  obliv bool repeated = 0;
  for(size_t i = 0; i < len1 + len2; i++) {
    M[i] = UINT32_MAX;
    obliv if(repeated) {
      repeated = 0;
    } else {
      if(i < len1 + len2 - 1) {
        obliv if(L[i].v == L[i+1].v) {
          M[i] = L[i].v;
          repeated = 1;
          count_intersection += 1;
        }
      }
    }
  }

  // Ideally, this would be a shuffle, but the ACK shuffle breaks on my laptop.
  osort_batcher(&ocCopyInt, M, len1+len2, cmp_uint32);

  // size_t intersection_size;
  // revealOblivLLong(&intersection_size, count_intersection, 0);
  // for(size_t i = 0; i < intersection_size; i++) {
  //   uint32_t el;
  //   revealOblivInt(&el, M[i], 1);
  //   if(ocCurrentParty() == 1) {
  //     printf("%d ", el);
  //   }
  // }
  // if(ocCurrentParty() == 1) {
  //   printf("\n");
  // }

  double end = wallclock_millis();
  args->result_time = end - start;

  free(L);
  free(M);
}
