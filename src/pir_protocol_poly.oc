#include "pir_protocol_poly.h"
#include <oaes.oh>
#include <bcrandom.h>

void pir_poly_oblivc(void *vargs) {
  pir_poly_oblivc_args *args = vargs;

  // get party inputs
  size_t block_size = ocBroadcastLLong(args->input_size, 1);
  size_t ciphertexts_size = ocBroadcastLLong(args->input_size, 2);
  // always pairs of blocks (ciphertext, counter)
  size_t num_ciphertexts = (ciphertexts_size / block_size) / 2;
  obliv uint8_t *ciphertexts = calloc(ciphertexts_size, sizeof(obliv uint8_t));
  obliv uint8_t *key = calloc(176, sizeof(obliv uint8_t));
  // create shares
  if(ocCurrentParty() == 1) {
    BCipherRandomGen* rand = newBCipherRandomGen();
    randomizeBuffer(rand, args->result, num_ciphertexts * args->value_type_size);
    releaseBCipherRandomGen(rand);
  }
  obliv uint8_t *result1 = calloc(num_ciphertexts, sizeof(obliv uint8_t) * args->value_type_size);
  obliv uint8_t *result2 = calloc(num_ciphertexts, sizeof(obliv uint8_t) * args->value_type_size);
  feedOblivCharArray(ciphertexts, args->input, ciphertexts_size, 2);
  feedOblivCharArray(key, args->input, block_size, 1);
  feedOblivCharArray(result1, args->result, num_ciphertexts * args->value_type_size, 1);

  // decrypt
  oaes_128_expandkey(key);
  obliv uint8_t *plaintexts = calloc(ciphertexts_size/2, sizeof(obliv uint8_t));
  for(size_t i = 0; i < num_ciphertexts; i++) {
    // encrypt counter and xor to ciphertext
    oaes_128_from_expanded(plaintexts + i*block_size, key, ciphertexts + (i*2+1)*block_size);
    for(size_t j = 0; j < block_size; j++) {
      plaintexts[i*block_size + j] ^= ciphertexts[i*2*block_size + j];
    }
  }

  for(size_t i = 0; i < num_ciphertexts; i++) {
    obliv bool ok = 1;
    // check if decryption was successful
    for(size_t j = 0; j < args->statistical_security / 8; j++) {
      ok &= (plaintexts[i*block_size + j] == 0);
    }
    size_t offset = args->statistical_security / 8;
    // byte-wise subtraction for arbitrary value_type_sizes
    obliv uint16_t rem = 1;
    for(size_t j = 0; j < args->value_type_size; j++) {
      obliv if(ok) {
        rem += plaintexts[i*block_size + offset + j];
      }
      rem += (obliv uint8_t) (result1[i*args->value_type_size + j] ^ 0xFF);
      result2[i*args->value_type_size + j] = (obliv uint8_t) rem;
      rem >>= 8;
    }
  }
  revealOblivCharArray(args->result, result2, num_ciphertexts * args->value_type_size, 2);

  oflush(ocCurrentProto());
  free(result1);
  free(result2);
  free(ciphertexts);
  free(plaintexts);
  free(key);
}
